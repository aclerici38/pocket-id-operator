// Package pocketid provides a clean wrapper around the Pocket-ID API client.
package pocketid

import (
	"context"
	"fmt"
	"net/url"
	"sort"
	"time"

	"github.com/go-openapi/runtime"
	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"

	apiclient "github.com/aclerici38/pocket-id-go-client/v2/client"
	"github.com/aclerici38/pocket-id-go-client/v2/client/api_keys"
	custom_claims "github.com/aclerici38/pocket-id-go-client/v2/client/custom_claims"
	oidc "github.com/aclerici38/pocket-id-go-client/v2/client/o_id_c"
	scim "github.com/aclerici38/pocket-id-go-client/v2/client/s_c_i_m"
	"github.com/aclerici38/pocket-id-go-client/v2/client/user_groups"
	"github.com/aclerici38/pocket-id-go-client/v2/client/users"
	pocketidversion "github.com/aclerici38/pocket-id-go-client/v2/client/version"
	"github.com/aclerici38/pocket-id-go-client/v2/models"
)

// Client wraps the autogenerated Pocket-ID API client with a cleaner interface.
// Each client is immutable after creation.
type Client struct {
	raw     *apiclient.PocketIDAPI
	baseURL string
}

// User represents a Pocket-ID user with clean field names.
type User struct {
	ID          string
	Username    string
	FirstName   string
	LastName    string
	Email       string
	DisplayName string
	IsAdmin     bool
	Disabled    bool
	Locale      string
}

// APIKey represents a Pocket-ID API key.
type APIKey struct {
	ID          string
	Name        string
	Description string
	CreatedAt   string
	ExpiresAt   string
	LastUsedAt  string
}

// APIKeyWithToken is returned when creating an API key. The token is a one-time token.
type APIKeyWithToken struct {
	APIKey
	Token string
}

// OIDCClient represents an OIDC client with key configuration.
type OIDCClient struct {
	ID                       string
	Name                     string
	CallbackURLs             []string
	LogoutCallbackURLs       []string
	LaunchURL                string
	LogoURL                  string
	DarkLogoURL              string
	HasLogo                  bool
	HasDarkLogo              bool
	IsPublic                 bool
	IsGroupRestricted        bool
	PKCEEnabled              bool
	RequiresReauthentication bool
	AllowedUserGroupIDs      []string
}

// ToInput converts an OIDCClient into an OIDCClientInput for comparison with desired state.
// ID and Credentials are not included since they aren't returned by the GET API.
// AllowedUserGroupIDs is managed separately and excluded from the input.
func (c *OIDCClient) ToInput() OIDCClientInput {
	return OIDCClientInput{
		Name:                     c.Name,
		CallbackURLs:             c.CallbackURLs,
		LogoutCallbackURLs:       c.LogoutCallbackURLs,
		LaunchURL:                c.LaunchURL,
		LogoURL:                  c.LogoURL,
		DarkLogoURL:              c.DarkLogoURL,
		HasLogo:                  c.HasLogo,
		HasDarkLogo:              c.HasDarkLogo,
		IsPublic:                 c.IsPublic,
		IsGroupRestricted:        c.IsGroupRestricted,
		PKCEEnabled:              c.PKCEEnabled,
		RequiresReauthentication: c.RequiresReauthentication,
	}
}

// OIDCClientFederatedIdentity represents a federated identity for OIDC clients.
type OIDCClientFederatedIdentity struct {
	Issuer   string
	Subject  string
	Audience string
	JWKS     string
}

// OIDCClientCredentials holds optional federated identity configuration.
type OIDCClientCredentials struct {
	FederatedIdentities []OIDCClientFederatedIdentity
}

// OIDCClientInput contains fields for creating or updating an OIDC client.
type OIDCClientInput struct {
	ID                       *string // nil means let Pocket-ID autogenerate
	Name                     string
	CallbackURLs             []string
	LogoutCallbackURLs       []string
	LaunchURL                string
	LogoURL                  string
	DarkLogoURL              string
	HasLogo                  bool
	HasDarkLogo              bool
	IsPublic                 bool
	IsGroupRestricted        bool
	PKCEEnabled              bool
	RequiresReauthentication bool
	Credentials              *OIDCClientCredentials
}

// Equal compares two OIDCClientInputs for equality on the fields that can be
// compared (excludes ID and Credentials which are create-time or write-only).
func (i OIDCClientInput) Equal(other OIDCClientInput) bool {
	if i.Name != other.Name ||
		i.LaunchURL != other.LaunchURL ||
		i.LogoURL != other.LogoURL ||
		i.DarkLogoURL != other.DarkLogoURL ||
		i.HasLogo != other.HasLogo ||
		i.HasDarkLogo != other.HasDarkLogo ||
		i.IsPublic != other.IsPublic ||
		i.IsGroupRestricted != other.IsGroupRestricted ||
		i.PKCEEnabled != other.PKCEEnabled ||
		i.RequiresReauthentication != other.RequiresReauthentication {
		return false
	}
	if !SortedEqual(i.CallbackURLs, other.CallbackURLs) {
		return false
	}
	if !SortedEqual(i.LogoutCallbackURLs, other.LogoutCallbackURLs) {
		return false
	}
	return true
}

// CustomClaim represents a custom claim key/value pair.
type CustomClaim struct {
	Key   string
	Value string
}

// SCIMServiceProvider represents a SCIM service provider configuration linked to an OIDC client.
type SCIMServiceProvider struct {
	ID           string
	Endpoint     string
	Token        string
	OIDCClientID string
	CreatedAt    string
	LastSyncedAt string
}

// SCIMServiceProviderInput is used to create or update a SCIM service provider.
type SCIMServiceProviderInput struct {
	Endpoint     string
	OIDCClientID string
	Token        string
}

// UserGroup represents a Pocket-ID user group.
type UserGroup struct {
	ID                   string
	Name                 string
	FriendlyName         string
	CreatedAt            string
	LdapID               string
	UserCount            int
	UserIDs              []string
	CustomClaims         []CustomClaim
	AllowedOIDCClientIDs []string
}

// UserGroupInput contains the fields the operator manages for a user group.
// AllowedOIDCClientIDs is excluded because the OIDC client controller owns that relationship.
type UserGroupInput struct {
	Name         string
	FriendlyName string
	CustomClaims []CustomClaim
	UserIDs      []string
}

// ToInput converts a UserGroup into a UserGroupInput for comparison with desired state.
func (g *UserGroup) ToInput() UserGroupInput {
	return UserGroupInput{
		Name:         g.Name,
		FriendlyName: g.FriendlyName,
		CustomClaims: g.CustomClaims,
		UserIDs:      g.UserIDs,
	}
}

// Equal compares two UserGroupInputs for equality.
func (i UserGroupInput) Equal(other UserGroupInput) bool {
	if i.Name != other.Name || i.FriendlyName != other.FriendlyName {
		return false
	}
	if !SortedEqual(i.UserIDs, other.UserIDs) {
		return false
	}
	if !customClaimsEqual(i.CustomClaims, other.CustomClaims) {
		return false
	}
	return true
}

func customClaimsEqual(a, b []CustomClaim) bool {
	if len(a) == 0 && len(b) == 0 {
		return true
	}
	if len(a) != len(b) {
		return false
	}
	aMap := make(map[string]string, len(a))
	for _, c := range a {
		aMap[c.Key] = c.Value
	}
	for _, c := range b {
		if v, ok := aMap[c.Key]; !ok || v != c.Value {
			return false
		}
	}
	return true
}

// SortedEqual compares two string slices for equality regardless of order.
func SortedEqual(a, b []string) bool {
	if len(a) == 0 && len(b) == 0 {
		return true
	}
	if len(a) != len(b) {
		return false
	}
	aCopy := make([]string, len(a))
	bCopy := make([]string, len(b))
	copy(aCopy, a)
	copy(bCopy, b)
	sort.Strings(aCopy)
	sort.Strings(bCopy)
	for i := range aCopy {
		if aCopy[i] != bCopy[i] {
			return false
		}
	}
	return true
}

// NewClient creates a new Pocket-ID client for the given base URL with optional API key.
func NewClient(baseURL string, apiKey string) (*Client, error) {
	parsed, err := url.Parse(baseURL)
	if err != nil {
		return nil, fmt.Errorf("parse base URL: %w", err)
	}

	transport := httptransport.New(parsed.Host, "/", []string{parsed.Scheme})

	if apiKey != "" {
		transport.DefaultAuthentication = runtime.ClientAuthInfoWriterFunc(
			func(req runtime.ClientRequest, reg strfmt.Registry) error {
				return req.SetHeaderParam("X-API-KEY", apiKey)
			},
		)
	}

	raw := apiclient.New(transport, strfmt.Default)

	return &Client{
		raw:     raw,
		baseURL: parsed.Scheme + "://" + parsed.Host,
	}, nil
}

// --- Version Operations ---

// GetCurrentVersion returns the currently deployed version of the PocketID instance.
func (c *Client) GetCurrentVersion(ctx context.Context) (string, error) {
	params := pocketidversion.NewGetAPIVersionCurrentParamsWithContext(ctx)
	resp, err := c.raw.Version.GetAPIVersionCurrent(params)
	if err != nil {
		return "", fmt.Errorf("get current version failed: %w", err)
	}
	v, ok := resp.Payload["currentVersion"]
	if !ok {
		return "", fmt.Errorf("currentVersion key missing from response")
	}
	return v, nil
}

// --- User Operations ---

func (c *Client) GetUser(ctx context.Context, id string) (*User, error) {
	params := users.NewGetAPIUsersIDParams().
		WithContext(ctx).
		WithID(id)

	resp, err := c.raw.Users.GetAPIUsersID(params)
	if err != nil {
		return nil, fmt.Errorf("get user failed: %w", err)
	}

	return userFromDTO(resp.Payload), nil
}

// ListUsers returns a list of users matching the search term.
// If search is empty, all users are returned.
func (c *Client) ListUsers(ctx context.Context, search string) ([]*User, error) {
	params := users.NewGetAPIUsersParams().WithContext(ctx)

	if search != "" {
		params = params.WithSearch(&search)
	}

	resp, err := c.raw.Users.GetAPIUsers(params)
	if err != nil {
		return nil, fmt.Errorf("list users failed: %w", err)
	}

	userList := make([]*User, 0, len(resp.Payload.Data))
	for _, dto := range resp.Payload.Data {
		userList = append(userList, userFromDTO(dto))
	}

	return userList, nil
}

// UserInput contains the fields for creating or updating a user.
type UserInput struct {
	Username    string
	FirstName   string
	LastName    string
	Email       string
	DisplayName string
	IsAdmin     bool
	Disabled    bool
	Locale      string
}

// ToInput converts a User into a UserInput for comparison with desired state.
func (u *User) ToInput() UserInput {
	return UserInput{
		Username:    u.Username,
		FirstName:   u.FirstName,
		LastName:    u.LastName,
		Email:       u.Email,
		DisplayName: u.DisplayName,
		IsAdmin:     u.IsAdmin,
		Disabled:    u.Disabled,
		Locale:      u.Locale,
	}
}

func (c *Client) CreateUser(ctx context.Context, input UserInput) (*User, error) {
	params := users.NewPostAPIUsersParams().
		WithContext(ctx).
		WithUser(&models.GithubComPocketIDPocketIDBackendInternalDtoUserCreateDto{
			Username:    &input.Username,
			FirstName:   &input.FirstName,
			LastName:    input.LastName,
			Email:       input.Email,
			DisplayName: &input.DisplayName,
			IsAdmin:     input.IsAdmin,
			Disabled:    input.Disabled,
			Locale:      input.Locale,
		})

	resp, err := c.raw.Users.PostAPIUsers(params)
	if err != nil {
		return nil, fmt.Errorf("create user failed: %w", err)
	}

	return userFromDTO(resp.Payload), nil
}

// UpdateUser updates an existing user.
func (c *Client) UpdateUser(ctx context.Context, id string, input UserInput) (*User, error) {
	params := users.NewPutAPIUsersIDParams().
		WithContext(ctx).
		WithID(id).
		WithUser(&models.GithubComPocketIDPocketIDBackendInternalDtoUserCreateDto{
			Username:    &input.Username,
			FirstName:   &input.FirstName,
			LastName:    input.LastName,
			Email:       input.Email,
			DisplayName: &input.DisplayName,
			IsAdmin:     input.IsAdmin,
			Disabled:    input.Disabled,
			Locale:      input.Locale,
		})

	resp, err := c.raw.Users.PutAPIUsersID(params)
	if err != nil {
		return nil, fmt.Errorf("update user failed: %w", err)
	}

	return userFromDTO(resp.Payload), nil
}

func (c *Client) DeleteUser(ctx context.Context, id string) error {
	params := users.NewDeleteAPIUsersIDParams().
		WithContext(ctx).
		WithID(id)

	_, err := c.raw.Users.DeleteAPIUsersID(params)
	if err != nil {
		return fmt.Errorf("delete user failed: %w", err)
	}

	return nil
}

// --- API Key Operations ---

// CreateAPIKeyForUser creates an API key for the specified user by exchanging a one-time access token for a session.
func (c *Client) CreateAPIKeyForUser(ctx context.Context, userID, name, expiresAt, description string, tokenTTLMinutes int) (*APIKeyWithToken, error) {
	token, err := c.CreateOneTimeAccessToken(ctx, userID, tokenTTLMinutes)
	if err != nil {
		return nil, fmt.Errorf("create one-time access token: %w", err)
	}

	session := newSessionClient(c.baseURL, nil)
	cookies, err := session.exchangeOneTimeAccessToken(ctx, token.Token)
	if err != nil {
		return nil, fmt.Errorf("exchange one-time access token: %w", err)
	}

	apiKeyReq := CreateAPIKeyRequest{
		Name:        name,
		ExpiresAt:   expiresAt,
		Description: description,
	}
	apiKeyResp, err := session.createAPIKeyWithCookies(ctx, cookies, apiKeyReq)
	if err != nil {
		return nil, fmt.Errorf("create API key: %w", err)
	}

	return &APIKeyWithToken{
		APIKey: apiKeyFromCreateResponse(apiKeyResp),
		Token:  apiKeyResp.Token,
	}, nil
}

// DeleteAPIKey deletes an API key by ID.
func (c *Client) DeleteAPIKey(ctx context.Context, id string) error {
	params := api_keys.NewDeleteAPIAPIKeysIDParams().
		WithContext(ctx).
		WithID(id)

	_, err := c.raw.APIKeys.DeleteAPIAPIKeysID(params)
	if err != nil {
		return fmt.Errorf("delete API key failed: %w", err)
	}

	return nil
}

// --- OIDC Client Operations ---

// ListOIDCClients returns a list of OIDC clients matching the search term.
// If search is empty, all OIDC clients are returned.
func (c *Client) ListOIDCClients(ctx context.Context, search string) ([]*OIDCClient, error) {
	params := oidc.NewGetAPIOidcClientsParams().WithContext(ctx)

	if search != "" {
		params = params.WithSearch(&search)
	}

	resp, err := c.raw.OIDc.GetAPIOidcClients(params)
	if err != nil {
		return nil, fmt.Errorf("list OIDC clients failed: %w", err)
	}

	clientList := make([]*OIDCClient, 0, len(resp.Payload.Data))
	for _, dto := range resp.Payload.Data {
		clientList = append(clientList, oidcClientFromListDTO(dto))
	}

	return clientList, nil
}

func (c *Client) CreateOIDCClient(ctx context.Context, input OIDCClientInput) (*OIDCClient, error) {
	dto := &models.GithubComPocketIDPocketIDBackendInternalDtoOidcClientCreateDto{
		Name:                     &input.Name,
		CallbackURLs:             input.CallbackURLs,
		LogoutCallbackURLs:       input.LogoutCallbackURLs,
		LaunchURL:                input.LaunchURL,
		LogoURL:                  input.LogoURL,
		DarkLogoURL:              input.DarkLogoURL,
		HasLogo:                  input.HasLogo,
		HasDarkLogo:              input.HasDarkLogo,
		IsPublic:                 input.IsPublic,
		IsGroupRestricted:        input.IsGroupRestricted,
		PkceEnabled:              input.PKCEEnabled,
		RequiresReauthentication: input.RequiresReauthentication,
		Credentials:              oidcCredentialsToDTO(input.Credentials),
	}

	// Only set ID if explicitly provided; otherwise let Pocket-ID autogenerate
	if input.ID != nil {
		dto.ID = *input.ID
	}

	params := oidc.NewPostAPIOidcClientsParams().
		WithContext(ctx).
		WithClient(dto)

	resp, err := c.raw.OIDc.PostAPIOidcClients(params)
	if err != nil {
		return nil, fmt.Errorf("create OIDC client failed: %w", err)
	}

	return oidcClientFromAllowedGroupsDTO(resp.Payload), nil
}

func (c *Client) UpdateOIDCClient(ctx context.Context, id string, input OIDCClientInput) (*OIDCClient, error) {
	params := oidc.NewPutAPIOidcClientsIDParams().
		WithContext(ctx).
		WithID(id).
		WithClient(&models.GithubComPocketIDPocketIDBackendInternalDtoOidcClientUpdateDto{
			Name:                     &input.Name,
			CallbackURLs:             input.CallbackURLs,
			LogoutCallbackURLs:       input.LogoutCallbackURLs,
			LaunchURL:                input.LaunchURL,
			LogoURL:                  input.LogoURL,
			DarkLogoURL:              input.DarkLogoURL,
			HasLogo:                  input.HasLogo,
			HasDarkLogo:              input.HasDarkLogo,
			IsPublic:                 input.IsPublic,
			IsGroupRestricted:        input.IsGroupRestricted,
			PkceEnabled:              input.PKCEEnabled,
			RequiresReauthentication: input.RequiresReauthentication,
			Credentials:              oidcCredentialsToDTO(input.Credentials),
		})

	resp, err := c.raw.OIDc.PutAPIOidcClientsID(params)
	if err != nil {
		return nil, fmt.Errorf("update OIDC client failed: %w", err)
	}

	return oidcClientFromAllowedGroupsDTO(resp.Payload), nil
}

func (c *Client) GetOIDCClient(ctx context.Context, id string) (*OIDCClient, error) {
	params := oidc.NewGetAPIOidcClientsIDParams().
		WithContext(ctx).
		WithID(id)

	resp, err := c.raw.OIDc.GetAPIOidcClientsID(params)
	if err != nil {
		return nil, fmt.Errorf("get OIDC client failed: %w", err)
	}

	return oidcClientFromAllowedGroupsDTO(resp.Payload), nil
}

func (c *Client) DeleteOIDCClient(ctx context.Context, id string) error {
	params := oidc.NewDeleteAPIOidcClientsIDParams().
		WithContext(ctx).
		WithID(id)

	_, err := c.raw.OIDc.DeleteAPIOidcClientsID(params)
	if err != nil {
		return fmt.Errorf("delete OIDC client failed: %w", err)
	}

	return nil
}

func (c *Client) UpdateOIDCClientAllowedGroups(ctx context.Context, id string, groupIDs []string) error {
	// Retry on 500 errors as it's usually transient
	retryDelays := []time.Duration{150 * time.Millisecond, 350 * time.Millisecond}
	var lastErr error
	for attempt := 0; attempt <= len(retryDelays); attempt++ {
		if attempt > 0 {
			select {
			case <-ctx.Done():
				return ctx.Err()
			case <-time.After(retryDelays[attempt-1]):
			}
		}
		params := oidc.NewPutAPIOidcClientsIDAllowedUserGroupsParams().
			WithContext(ctx).
			WithID(id).
			WithGroups(&models.GithubComPocketIDPocketIDBackendInternalDtoOidcUpdateAllowedUserGroupsDto{
				UserGroupIds: groupIDs,
			})
		if _, err := c.raw.OIDc.PutAPIOidcClientsIDAllowedUserGroups(params); err != nil {
			if IsServerError(err) {
				lastErr = fmt.Errorf("update OIDC client allowed groups failed: %w", err)
				continue
			}
			return fmt.Errorf("update OIDC client allowed groups failed: %w", err)
		}
		return nil
	}
	return lastErr
}

// RegenerateOIDCClientSecret regenerates the client secret and returns it.
// This is the only way to retrieve the client secret from Pocket ID.
// The secret is only returned once and cannot be retrieved later without re-generating
func (c *Client) RegenerateOIDCClientSecret(ctx context.Context, id string) (string, error) {
	params := oidc.NewPostAPIOidcClientsIDSecretParams().
		WithContext(ctx).
		WithID(id)

	resp, err := c.raw.OIDc.PostAPIOidcClientsIDSecret(params)
	if err != nil {
		return "", fmt.Errorf("regenerate OIDC client secret failed: %w", err)
	}

	// The response payload is `any` type, so we need to type assert
	payload, ok := resp.GetPayload().(map[string]any)
	if !ok {
		return "", fmt.Errorf("unexpected response format")
	}

	secret, ok := payload["secret"].(string)
	if !ok {
		return "", fmt.Errorf("secret not found in response")
	}

	return secret, nil
}

// --- SCIM Service Provider Operations ---

// GetOIDCClientSCIMServiceProvider fetches the SCIM service provider configured for an OIDC client.
// Returns nil, nil if no SCIM service provider is configured (404).
func (c *Client) GetOIDCClientSCIMServiceProvider(ctx context.Context, oidcClientID string) (*SCIMServiceProvider, error) {
	params := oidc.NewGetAPIOidcClientsIDScimServiceProviderParams().
		WithContext(ctx).
		WithID(oidcClientID)

	resp, err := c.raw.OIDc.GetAPIOidcClientsIDScimServiceProvider(params)
	if err != nil {
		if IsNotFoundError(err) {
			return nil, nil
		}
		return nil, fmt.Errorf("get OIDC client SCIM service provider failed: %w", err)
	}

	return scimFromDTO(resp.Payload), nil
}

// CreateSCIMServiceProvider creates a new SCIM service provider.
func (c *Client) CreateSCIMServiceProvider(ctx context.Context, input SCIMServiceProviderInput) (*SCIMServiceProvider, error) {
	params := scim.NewPostAPIScimServiceProviderParams().
		WithContext(ctx).
		WithServiceProvider(&models.GithubComPocketIDPocketIDBackendInternalDtoScimServiceProviderCreateDTO{
			Endpoint:     &input.Endpoint,
			OidcClientID: &input.OIDCClientID,
			Token:        input.Token,
		})

	resp, err := c.raw.Scim.PostAPIScimServiceProvider(params)
	if err != nil {
		return nil, fmt.Errorf("create SCIM service provider failed: %w", err)
	}

	return scimFromDTO(resp.Payload), nil
}

// UpdateSCIMServiceProvider updates an existing SCIM service provider.
func (c *Client) UpdateSCIMServiceProvider(ctx context.Context, id string, input SCIMServiceProviderInput) (*SCIMServiceProvider, error) {
	params := scim.NewPutAPIScimServiceProviderIDParams().
		WithContext(ctx).
		WithID(id).
		WithServiceProvider(&models.GithubComPocketIDPocketIDBackendInternalDtoScimServiceProviderCreateDTO{
			Endpoint:     &input.Endpoint,
			OidcClientID: &input.OIDCClientID,
			Token:        input.Token,
		})

	resp, err := c.raw.Scim.PutAPIScimServiceProviderID(params)
	if err != nil {
		return nil, fmt.Errorf("update SCIM service provider failed: %w", err)
	}

	return scimFromDTO(resp.Payload), nil
}

// DeleteSCIMServiceProvider deletes a SCIM service provider by its pocket-id ID.
func (c *Client) DeleteSCIMServiceProvider(ctx context.Context, id string) error {
	params := scim.NewDeleteAPIScimServiceProviderIDParams().
		WithContext(ctx).
		WithID(id)

	if _, err := c.raw.Scim.DeleteAPIScimServiceProviderID(params); err != nil {
		return fmt.Errorf("delete SCIM service provider failed: %w", err)
	}

	return nil
}

// --- User Group Operations ---

// ListUserGroups returns a list of user groups matching the search term.
// If search is empty, all user groups are returned.
func (c *Client) ListUserGroups(ctx context.Context, search string) ([]*UserGroup, error) {
	params := user_groups.NewGetAPIUserGroupsParams().WithContext(ctx)

	if search != "" {
		params = params.WithSearch(&search)
	}

	resp, err := c.raw.UserGroups.GetAPIUserGroups(params)
	if err != nil {
		return nil, fmt.Errorf("list user groups failed: %w", err)
	}

	groupList := make([]*UserGroup, 0, len(resp.Payload.Data))
	for _, dto := range resp.Payload.Data {
		groupList = append(groupList, userGroupFromMinimalDTO(dto))
	}

	return groupList, nil
}

func (c *Client) CreateUserGroup(ctx context.Context, name, friendlyName string) (*UserGroup, error) {
	params := user_groups.NewPostAPIUserGroupsParams().
		WithContext(ctx).
		WithUserGroup(&models.GithubComPocketIDPocketIDBackendInternalDtoUserGroupCreateDto{
			Name:         &name,
			FriendlyName: &friendlyName,
		})

	resp, err := c.raw.UserGroups.PostAPIUserGroups(params)
	if err != nil {
		return nil, fmt.Errorf("create user group failed: %w", err)
	}

	return userGroupFromDTO(resp.Payload), nil
}

func (c *Client) UpdateUserGroup(ctx context.Context, id, name, friendlyName string) (*UserGroup, error) {
	params := user_groups.NewPutAPIUserGroupsIDParams().
		WithContext(ctx).
		WithID(id).
		WithUserGroup(&models.GithubComPocketIDPocketIDBackendInternalDtoUserGroupCreateDto{
			Name:         &name,
			FriendlyName: &friendlyName,
		})

	resp, err := c.raw.UserGroups.PutAPIUserGroupsID(params)
	if err != nil {
		return nil, fmt.Errorf("update user group failed: %w", err)
	}

	return userGroupFromDTO(resp.Payload), nil
}

func (c *Client) GetUserGroup(ctx context.Context, id string) (*UserGroup, error) {
	params := user_groups.NewGetAPIUserGroupsIDParams().
		WithContext(ctx).
		WithID(id)

	resp, err := c.raw.UserGroups.GetAPIUserGroupsID(params)
	if err != nil {
		return nil, fmt.Errorf("get user group failed: %w", err)
	}

	return userGroupFromDTO(resp.Payload), nil
}

func (c *Client) DeleteUserGroup(ctx context.Context, id string) error {
	params := user_groups.NewDeleteAPIUserGroupsIDParams().
		WithContext(ctx).
		WithID(id)

	if _, err := c.raw.UserGroups.DeleteAPIUserGroupsID(params); err != nil {
		return fmt.Errorf("delete user group failed: %w", err)
	}

	return nil
}

func (c *Client) UpdateUserGroupUsers(ctx context.Context, id string, userIDs []string) error {
	params := user_groups.NewPutAPIUserGroupsIDUsersParams().
		WithContext(ctx).
		WithID(id).
		WithUsers(&models.GithubComPocketIDPocketIDBackendInternalDtoUserGroupUpdateUsersDto{
			UserIds: userIDs,
		})

	if _, err := c.raw.UserGroups.PutAPIUserGroupsIDUsers(params); err != nil {
		return fmt.Errorf("update user group users failed: %w", err)
	}

	return nil
}

func (c *Client) UpdateUserGroupAllowedOIDCClients(ctx context.Context, id string, clientIDs []string) error {
	params := oidc.NewPutAPIUserGroupsIDAllowedOidcClientsParams().
		WithContext(ctx).
		WithID(id).
		WithGroups(&models.GithubComPocketIDPocketIDBackendInternalDtoUserGroupUpdateAllowedOidcClientsDto{
			OidcClientIds: clientIDs,
		})

	if _, err := c.raw.OIDc.PutAPIUserGroupsIDAllowedOidcClients(params); err != nil {
		return fmt.Errorf("update user group allowed OIDC clients failed: %w", err)
	}

	return nil
}

func (c *Client) UpdateUserGroupCustomClaims(ctx context.Context, id string, claims []CustomClaim) ([]CustomClaim, error) {
	payload := make([]*models.GithubComPocketIDPocketIDBackendInternalDtoCustomClaimCreateDto, 0, len(claims))
	for _, claim := range claims {
		key := claim.Key
		value := claim.Value
		payload = append(payload, &models.GithubComPocketIDPocketIDBackendInternalDtoCustomClaimCreateDto{
			Key:   &key,
			Value: &value,
		})
	}

	params := custom_claims.NewPutAPICustomClaimsUserGroupUserGroupIDParams().
		WithContext(ctx).
		WithUserGroupID(id).
		WithClaims(payload)

	resp, err := c.raw.CustomClaims.PutAPICustomClaimsUserGroupUserGroupID(params)
	if err != nil {
		return nil, fmt.Errorf("update user group custom claims failed: %w", err)
	}

	return customClaimsFromDTO(resp.Payload), nil
}

// --- One-Time Access Token Operations ---

// OneTimeAccessToken represents a one-time login token.
type OneTimeAccessToken struct {
	Token string
}

// CreateOneTimeAccessToken creates a one-time access token for a user.
// This token can be used to log in via the browser at /lc/{token}
func (c *Client) CreateOneTimeAccessToken(ctx context.Context, userID string, expiresInMinutes int) (*OneTimeAccessToken, error) {
	params := users.NewPostAPIUsersIDOneTimeAccessTokenParams().
		WithContext(ctx).
		WithID(userID).
		WithBody(map[string]any{
			"userId": userID,
			"ttl":    fmt.Sprintf("%dm", expiresInMinutes),
		})

	resp, err := c.raw.Users.PostAPIUsersIDOneTimeAccessToken(params)
	if err != nil {
		return nil, fmt.Errorf("create one-time access token failed: %w", err)
	}

	// The response payload is `any` type, so we need to type assert
	payload, ok := resp.Payload.(map[string]any)
	if !ok {
		return nil, fmt.Errorf("unexpected response format")
	}

	token, ok := payload["token"].(string)
	if !ok {
		return nil, fmt.Errorf("token not found in response")
	}

	return &OneTimeAccessToken{Token: token}, nil
}

// --- Helpers ---

// DefaultAPIKeyExpiry returns a default expiry time of 1 year from now for API keys.
func DefaultAPIKeyExpiry() time.Time {
	return time.Now().AddDate(1, 0, 0)
}

func userFromDTO(dto *models.GithubComPocketIDPocketIDBackendInternalDtoUserDto) *User {
	if dto == nil {
		return nil
	}
	return &User{
		ID:          dto.ID,
		Username:    dto.Username,
		FirstName:   dto.FirstName,
		LastName:    dto.LastName,
		Email:       dto.Email,
		DisplayName: dto.DisplayName,
		IsAdmin:     dto.IsAdmin,
		Disabled:    dto.Disabled,
		Locale:      dto.Locale,
	}
}

func apiKeyFromCreateResponse(resp *CreateAPIKeyResponse) APIKey {
	if resp == nil {
		return APIKey{}
	}
	return APIKey{
		ID:          resp.APIKey.ID,
		Name:        resp.APIKey.Name,
		Description: resp.APIKey.Description,
		CreatedAt:   resp.APIKey.CreatedAt,
		ExpiresAt:   resp.APIKey.ExpiresAt,
	}
}

func oidcCredentialsToDTO(credentials *OIDCClientCredentials) *models.GithubComPocketIDPocketIDBackendInternalDtoOidcClientCredentialsDto {
	if credentials == nil {
		return nil
	}
	identities := make([]*models.GithubComPocketIDPocketIDBackendInternalDtoOidcClientFederatedIdentityDto, 0, len(credentials.FederatedIdentities))
	for _, identity := range credentials.FederatedIdentities {
		identities = append(identities, &models.GithubComPocketIDPocketIDBackendInternalDtoOidcClientFederatedIdentityDto{
			Issuer:   identity.Issuer,
			Subject:  identity.Subject,
			Audience: identity.Audience,
			Jwks:     identity.JWKS,
		})
	}
	return &models.GithubComPocketIDPocketIDBackendInternalDtoOidcClientCredentialsDto{
		FederatedIdentities: identities,
	}
}

func oidcClientFromListDTO(dto *models.GithubComPocketIDPocketIDBackendInternalDtoOidcClientWithAllowedGroupsCountDto) *OIDCClient {
	if dto == nil {
		return nil
	}
	return &OIDCClient{
		ID:                       dto.ID,
		Name:                     dto.Name,
		CallbackURLs:             dto.CallbackURLs,
		LogoutCallbackURLs:       dto.LogoutCallbackURLs,
		LaunchURL:                dto.LaunchURL,
		LogoURL:                  "",
		DarkLogoURL:              "",
		HasLogo:                  dto.HasLogo,
		HasDarkLogo:              dto.HasDarkLogo,
		IsPublic:                 dto.IsPublic,
		IsGroupRestricted:        dto.IsGroupRestricted,
		PKCEEnabled:              dto.PkceEnabled,
		RequiresReauthentication: dto.RequiresReauthentication,
		AllowedUserGroupIDs:      []string{},
	}
}

func oidcClientFromAllowedGroupsDTO(dto *models.GithubComPocketIDPocketIDBackendInternalDtoOidcClientWithAllowedUserGroupsDto) *OIDCClient {
	if dto == nil {
		return nil
	}
	groupIDs := make([]string, 0, len(dto.AllowedUserGroups))
	for _, group := range dto.AllowedUserGroups {
		if group == nil || group.ID == "" {
			continue
		}
		groupIDs = append(groupIDs, group.ID)
	}
	return &OIDCClient{
		ID:                       dto.ID,
		Name:                     dto.Name,
		CallbackURLs:             dto.CallbackURLs,
		LogoutCallbackURLs:       dto.LogoutCallbackURLs,
		LaunchURL:                dto.LaunchURL,
		LogoURL:                  "",
		DarkLogoURL:              "",
		HasLogo:                  dto.HasLogo,
		HasDarkLogo:              dto.HasDarkLogo,
		IsPublic:                 dto.IsPublic,
		IsGroupRestricted:        dto.IsGroupRestricted,
		PKCEEnabled:              dto.PkceEnabled,
		RequiresReauthentication: dto.RequiresReauthentication,
		AllowedUserGroupIDs:      groupIDs,
	}
}

func userGroupFromMinimalDTO(dto *models.GithubComPocketIDPocketIDBackendInternalDtoUserGroupMinimalDto) *UserGroup {
	if dto == nil {
		return nil
	}
	return &UserGroup{
		ID:           dto.ID,
		Name:         dto.Name,
		FriendlyName: dto.FriendlyName,
		CreatedAt:    dto.CreatedAt,
		LdapID:       dto.LdapID,
		UserCount:    0,   // Minimal DTO doesn't include users
		CustomClaims: nil, // Minimal DTO doesn't include custom claims
	}
}

func userGroupFromDTO(dto *models.GithubComPocketIDPocketIDBackendInternalDtoUserGroupDto) *UserGroup {
	if dto == nil {
		return nil
	}
	userIds := make([]string, 0, len(dto.Users))
	for _, user := range dto.Users {
		if user != nil && user.ID != "" {
			userIds = append(userIds, user.ID)
		}
	}
	clientIDs := make([]string, 0, len(dto.AllowedOidcClients))
	for _, client := range dto.AllowedOidcClients {
		if client != nil && client.ID != "" {
			clientIDs = append(clientIDs, client.ID)
		}
	}
	return &UserGroup{
		ID:                   dto.ID,
		Name:                 dto.Name,
		FriendlyName:         dto.FriendlyName,
		CreatedAt:            dto.CreatedAt,
		LdapID:               dto.LdapID,
		UserCount:            len(dto.Users),
		UserIDs:              userIds,
		CustomClaims:         customClaimsFromDTO(dto.CustomClaims),
		AllowedOIDCClientIDs: clientIDs,
	}
}

func scimFromDTO(dto *models.GithubComPocketIDPocketIDBackendInternalDtoScimServiceProviderDTO) *SCIMServiceProvider {
	if dto == nil {
		return nil
	}
	oidcClientID := ""
	if dto.OidcClient != nil {
		oidcClientID = dto.OidcClient.ID
	}
	return &SCIMServiceProvider{
		ID:           dto.ID,
		Endpoint:     dto.Endpoint,
		Token:        dto.Token,
		OIDCClientID: oidcClientID,
		CreatedAt:    dto.CreatedAt,
		LastSyncedAt: dto.LastSyncedAt,
	}
}

func customClaimsFromDTO(dto []*models.GithubComPocketIDPocketIDBackendInternalDtoCustomClaimDto) []CustomClaim {
	if len(dto) == 0 {
		return nil
	}
	claims := make([]CustomClaim, 0, len(dto))
	for _, claim := range dto {
		if claim == nil {
			continue
		}
		claims = append(claims, CustomClaim{
			Key:   claim.Key,
			Value: claim.Value,
		})
	}
	if len(claims) == 0 {
		return nil
	}
	return claims
}
